package de.rbb.tkoll.cryptor;

import java.io.IOException;
import java.io.OutputStream;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Security;
import java.util.Date;
import org.bouncycastle.bcpg.ArmoredOutputStream;
import org.bouncycastle.bcpg.HashAlgorithmTags;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openpgp.PGPEncryptedData;
import org.bouncycastle.openpgp.PGPException;
import org.bouncycastle.openpgp.PGPKeyPair;
import org.bouncycastle.openpgp.PGPPublicKey;
import org.bouncycastle.openpgp.PGPSecretKey;
import org.bouncycastle.openpgp.PGPSignature;
import org.bouncycastle.openpgp.operator.PGPDigestCalculator;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPContentSignerBuilder;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPDigestCalculatorProviderBuilder;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPKeyPair;
import org.bouncycastle.openpgp.operator.jcajce.JcePBESecretKeyEncryptorBuilder;

/**
 * Taken from Bouncycastle-Examples.
 * @see https://github.com/bcgit/bc-java/blob/master/pg/src/main/java/org/bouncycastle/openpgp/examples/RSAKeyPairGenerator.java
 */
public class RSAKeyPairGenerator {
  // @formatter:off
  public void exportKeyPair(
      OutputStream secretOut, 
      OutputStream publicOut, 
      KeyPair keypair,
	  String identity, 
	  char[] passPhrase, 
	  boolean armor
	  ) throws PGPException, IOException {
    
    identity += " - generated by trh0 Cryptor";
    
	PGPDigestCalculator sha1Calc = new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
    PGPKeyPair          keyPair = new JcaPGPKeyPair(
        PGPPublicKey.RSA_GENERAL, 
        keypair, 
        new Date());
    
    PGPSecretKey secretKey = new PGPSecretKey(
        PGPSignature.DEFAULT_CERTIFICATION, 
        keyPair, 
        identity, 
        sha1Calc, 
        null, null, 
        new JcaPGPContentSignerBuilder(
            keyPair.getPublicKey().getAlgorithm(), 
            HashAlgorithmTags.SHA1), 
        new JcePBESecretKeyEncryptorBuilder(
            PGPEncryptedData.CAST5, 
            sha1Calc
            ).setProvider("BC").build(passPhrase));
	
    if (armor) {
      secretOut = new ArmoredOutputStream(secretOut);
    }
    
    secretKey.encode(secretOut);
    secretOut.close();
    
	// @formatter:on
    if (armor) {
      publicOut = new ArmoredOutputStream(publicOut);
    }

    PGPPublicKey key = secretKey.getPublicKey();
    key.encode(publicOut);
    publicOut.close();
  }

  public static final int KEYSIZE_1024BIT = 1024;
  public static final int KEYSIZE_2048BIT = 2048;
  public static final int KEYSIZE_4096BIT = 4096;
  /**
   * 
   * @param publicKeyOut Outputstream to write the key (raw or ASCII-armored) into
   * @param privateKeyOut Outputstream to write the key (raw or ASCII-armored) into
   * @param password Passphrase to protect the private key
   * @param keySize the RSA keysize
   * @param identify Comment appended to the key file
   * @param armored export ASCII - armored?
   * @throws Exception
   */
  public void genKeyPair(OutputStream publicKeyOut, OutputStream privateKeyOut, char[] password,
      int keySize, String identify, boolean armored) throws Exception {

    Security.addProvider(new BouncyCastleProvider());

    KeyPairGenerator kpg;
    try {
      kpg = KeyPairGenerator.getInstance("RSA", "BC");
    } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
      throw new PGPException("Fatal", e);
    }

    kpg.initialize(keySize);

    KeyPair kp = kpg.generateKeyPair();

    try {

      this.exportKeyPair(privateKeyOut, publicKeyOut, kp, identify, password, armored);

    } catch (IOException | PGPException e) {
      throw e;
    }

  }

}
